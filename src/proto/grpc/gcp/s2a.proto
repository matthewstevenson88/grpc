syntax = "proto3";

package s2a;

// The ciphersuites supported by S2A. The name determines the confidentiality,
// and authentication ciphers as well as the hash algorithm used for PRF in
// TLS 1.2 or HKDF in TLS 1.3. Thus, the components of the name are:
//  - AEAD -- for encryption and authentication, e.g., AES_128_GCM.
//  - Hash algorithm -- used in PRF or HKDF, e.g., SHA256.
enum Ciphersuite {
  AES_128_GCM_SHA256 = 0;
  AES_256_GCM_SHA384 = 1;
  CHACHA20_POLY1305_SHA256 = 2;
}

// The TLS versions supported by S2A's handshaker module.
enum TLSVersion {
  TLS1_2 = 0;
  TLS1_3 = 1;
}

message Identity {
  oneof identity_oneof {
    // The SPIFFE ID of a connection endpoint.
    string spiffe_id = 1;

    // The hostname of a connection endpoint.
    string hostname = 2;
  }

  // Additional identity-specific attributes.
  map<string, string> attributes = 3;
}

message ClientSessionStartReq {
  // The application protocols supported by the client, e.g., "grpc".
  repeated string application_protocols = 1;

  // (Optional) The minimum TLS version number that the S2A's handshaker module
  // will use to set up the session. If this field is not provided, S2A will use
  // the minimum version it supports.
  TLSVersion min_tls_version = 2;

  // (Optional) The maximum TLS version number that the S2A's handshaker module
  // will use to set up the session. If this field is not provided, S2A will use
  // the maximum version it supports.
  TLSVersion max_tls_version = 3;

  // The TLS ciphersuites that the client is willing to support.
  repeated Ciphersuite tls_ciphersuites = 4;

  // (Optional) Describes which server identities are acceptable by the client.
  // If target identities are provided and none of them matches the peer
  // identity of the server, session setup fails.
  repeated Identity target_identities = 5;

  // (Optional) Application may specify a local identity. Otherwise, S2A chooses
  // a default local identity. If a default identity cannot be determined,
  // session setup fails.
  Identity local_identity = 6;

  // (Optional) If target name is provided, server authorization check might be
  // performed by S2A if it is configured to do so. This check is intended to
  // verify that the peer authenticated identity is authorized to run a service
  // with the target name. If this field is populated it will be used in the SNI
  // extension.
  string target_name = 7;
}

message ServerSessionStartReq {
  // The application protocols supported by the server, e.g., "grpc".
  repeated string application_protocols = 1;

  // (Optional) The minimum TLS version number that the S2A's handshaker module
  // will use to set up the session. If this field is not provided, S2A will use
  // the minimum version it supports.
  TLSVersion min_tls_version = 2;

  // (Optional) The maximum TLS version number that the S2A's handshaker module
  // will use to set up the session. If this field is not provided, S2A will use
  // the maximum version it supports.
  TLSVersion max_tls_version = 3;

  // The TLS ciphersuites that the server is willing to support.
  repeated Ciphersuite tls_ciphersuites = 4;

  // (Optional) A list of local identities supported by the server, if
  // specified. Otherwise, S2A chooses a default local identity.
  repeated Identity local_identities = 5;

  // The byte representation of the first handshake message received from the
  // client peer. It is possible that this first message is split into multiple
  // chunks. In this case, the first chunk is sent using this field and the
  // following chunks are sent using the in_bytes field of SessionNextReq
  // Specifically, if the client peer is using S2A, this field contains the
  // bytes in the out_frames field of SessionResp message that the client peer
  // received from its S2A after initiating the handshake.
  bytes in_bytes = 6;
}

message SessionNextReq {
  // The byte representation of session setup, i.e., handshake messages.
  // Specifically:
  //  - All handshake messages sent from the server to the client.
  //  - All, except for the first, handshake messages sent from the client to
  //    the server. Note that the first message is communicated to S2A using the
  //    in_bytes field of ServerSessionStartReq.
  // If the peer is using S2A, this field contains the bytes in the out_frames
  // field of SessionResp message that the peer received from its S2A.
  bytes in_bytes = 1;
}

// TODO(b/139828121): This only allows client-side handling of resumption
//                    tickets. We need a way to pass the ticket from S2A to the
//                    server-side application.
message ResumptionTicketReq {
  // The byte representation of a NewSessionTicket message received from the
  // server.
  bytes in_bytes = 1;
}

message SessionReq {
  oneof req_oneof {
    // The client session setup request message.
    ClientSessionStartReq client_start = 1;

    // The server session setup request message.
    ServerSessionStartReq server_start = 2;

    // The next session setup message request message.
    SessionNextReq next = 3;

    // The resumption ticket that is received from the server. This message is
    // only accepted by S2A if it is running as a client and if it is received
    // after session setup is complete. If S2A is running as a server and it
    // receives this message, the session is terminated.
    ResumptionTicketReq resumption_ticket = 4;
  }
}

message SessionState {
  // The TLS version number that the S2A's handshaker module used to set up the
  // session.
  TLSVersion tls_version = 1;

  // The TLS ciphersuite negotiated by the that S2A's handshaker module.
  Ciphersuite tls_ciphersuite = 2;

  // The sequence number of the next, incoming, TLS record.
  uint64 in_sequence = 3;
  // The sequence number of the next, outgoing, TLS record.
  uint64 out_sequence = 4;

  // The key for the inbound direction.
  bytes in_key = 5;
  // The key for the outbound direction.
  bytes out_key = 6;

  // The constant part of the record nonce for the outbound direction.
  bytes in_fixed_nonce = 7;
  // The constant part of the record nonce for the inbound direction.
  bytes out_fixed_nonce = 8;

  // The HMAC secret for incoming records.
  bytes in_mac_secret = 9;
  // The HMAC secret for outgoing records.
  bytes out_mac_secret = 10;
}

message SessionResult {
  // The application protocol negotiated for this session.
  string application_protocol = 1;

  // The session state at the end. This state contains all cryptographic
  // material required to initialize the record protocol object.
  SessionState state = 2;

  // The authenticated identity of the peer.
  Identity peer_identity = 4;

  // The local identity used during session setup. This could be:
  //  - The local identity specified by the client.
  //  - One of the local identities specified by the server.
  //  - The default identity selected by S2A.
  Identity local_identity = 5;
}

message SessionStatus {
  // The status code that is specific to the application and the implementation
  // of S2A, e.g., gRPC status code.
  uint32 code = 1;

  // The status details.
  string details = 2;
}

message SessionResp {
  // The byte representation of the frames that should be sent to the peer. May
  // be empty if nothing needs to be sent to the peer or if in_bytes in the
  // SessionReq is incomplete. All bytes in a non-empty out_frames must be sent
  // to the peer even if the session setup status is not OK as these frames may
  // contain appropriate alerts.
  bytes out_frames = 1;

  // Number of bytes in the in_bytes field that are consumed by S2A. It is
  // possible that part of in_bytes is unrelated to the session setup process.
  uint32 bytes_consumed = 2;

  // This is set if the session is successfully set up. out_frames may
  // still be set to frames that needs to be forwarded to the peer.
  SessionResult result = 3;

  // Status of session setup at the current stage.
  SessionStatus status = 4;
}

service S2AService {
  // S2A service accepts a stream of session setup requests and returns a stream
  // of session setup responses. The client of this service is expected to send
  // exactly one client_start or server_start message followed by at least one
  // next message. Applications running TLS clients can send requests with
  // resumption_ticket messages only after the session is successfully set up.
  //
  // Every time S2A client sends a request, this service sends a response.
  // However, clients do not have to wait for service response before sending
  // the next request.
  rpc SetUpSession(stream SessionReq) returns (stream SessionResp) {}
}
